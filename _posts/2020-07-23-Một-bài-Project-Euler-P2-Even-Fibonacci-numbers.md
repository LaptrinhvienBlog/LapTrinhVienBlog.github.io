---
layout: post
title: Một bài Project Euler P2 Even Fibonacci numbers
summary: Lại là mình, một lập trình viên trong một ngày rảnh rỗi và lại lôi hackerrank ra luyện gõ phím. Với tham vọng sẽ giải hết 254 bài trong project Euler của Hackerrank và viết về hành trình này đến cho các bạn, hôm nay mình sẽ đến với bài số 2 của cuộc hành trình.
date: 2020-07-23 22:10
categories: Programming Algorithm
---

Lại là mình, một lập trình viên trong một ngày rảnh rỗi và lại lôi hackerrank ra luyện gõ phím. Với tham vọng sẽ giải hết 254 bài trong project Euler của Hackerrank và viết về hành trình này đến cho các bạn, hôm nay mình sẽ đến với bài số 2 của cuộc hành trình.

## Đề
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with and 1, 2 the first 10 terms will be:
```
1, 2, 3, 5, 8, 13, 21, 34, 55, 89,...
```
By considering the terms in the Fibonacci sequence whose values do not exceed _N_, find the sum of the even-valued terms.

**Input Format**
First line contains _T_ that denotes the number of test cases. 
This is followed by lines, each containing an integer _N_

**Constraints**
_1 <= T <= 10^5_
_10 <= N <=10^16_

**Tạm dịch**
Mỗi số Fibonacci được sinh ra bằng cách lấy tổng của hai số liền trước. Với hai phần tử đầu là 1, 2 thì 10 số Fibonacci đầu tiên là
```
1, 2, 3, 5, 8, 13, 21, 34, 55, 89,...
```

Với những số Fibonacci không vượt quá _N_, tính tổng những số chẵn.

[Đề gốc](https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problem)

## Không nói nhiều nữa, bắt tay vào làm thôi

```
Các bạn nên thử tự làm trước khi đọc xuống dưới.
```

### Lần thử đầu tiên: Vét cạn
Vâng, không cần nghĩ ngợi gì nhiều, vứt hết não ra và viết chương trình chạy được, chạy đúng trước khi làm cho nó chạy nhanh.

Thuật toán vét cạn cho bài này thì quá đơn giản rồi nên mình sẽ không trình bày nhiều, cứ lần lượt sinh ra từng số Fibonnaci, nếu lớn hơn _N_, dừng chương trình, nếu nó chẵn thêm vào kết quả.

Code C++:
```c++
#include  <iostream>

using  namespace std;

long  long SumEvenFibonnaci(long  long limit);

int main()
{
	int tests;
	cin >> tests;
	for (int i = 0; i < tests; i++)
	{
		long  long n;
		cin >> n;
		cout << SumEvenFibonnaci(n) << endl;
	}

	return  0;
}
```

Hàm ```SumEvenFibonnaci``` viết như sau

Code C++
```c++
long  long SumEvenFibonnaci(long  long limit)
{
	long  long result = 0;
	long  long f1 = 1;
	long  long f2 = 2;
	
	while (f2 <= limit)
	{
		// Kiem tra neu f2 chan, co the thay bang f2 % 2 == 0
		if ((f2 & 1) == 0)
		{
			result += f2;
		}
		long  long temp = f2;
		f2 += f1;
		f1 = temp;
	}
	
	return result;
}
```

Và chạy thử trên Hackerrank
![Hackerrank project euler bài 2 tổng fibonacci chẵn sum of ficonacci lập trình c++](https://lh3.googleusercontent.com/hsqmnTja4Ymo83PZlWyZzWzg4SNT9i3auwIrK5ag58CMk8DhisJzQM5N0vn0UKreQXg3-RuXilsL0yAh0tcVxZRBhSYEB08fvixzC1wX4i7swc4OxxGQrTNYBW3PmHXiNp4gEhczNg=w2400)

Các bạn thấy gì không? Vâng, các bạn không nhìn nhầm đâu, pass **5/5** tests.

Mình tại thời điểm chạy thử này cũng kiểu 
![Yo WTF man](https://i.kym-cdn.com/entries/icons/mobile/000/018/489/nick-young-confused-face-300x256-nqlyaa.jpg)

Ơ sao dễ thế này, dễ thế thôi làm gì nữa. Và thế là mình pass Project Euler #2 chỉ với lần thử đầu tiên.

### Tối ưu một tí: phương pháp sinh
Nếu các bạn chưa biết về thuật toán sinh  thì có thể đọc lại [Project Euler #1](https://laptrinhvienblog.github.io/programming/algorithm/2020/05/21/M%E1%BB%99t-b%C3%A0i-Project-Euler-P1-Multiples-of-3-and-5/)

Về cơ bản mình sẽ dùng phương pháp sinh để sinh ra những số Fibonacci chẵn thay vì lặp qua tất cả các số Fibonacci và kiểm tra tính chẵn lẻ.

Vậy sinh các số Fibonnaci chẵn như thế nào. Đầu tiên chúng ta sẽ xem xét lại dáy Fibonnaci và chú ý đến các số chẵn

1, **2**, 3, 5, **8**, 13, 21, **34**, 55, 89, **144**,...

Chúng ta dễ dàng nhận thấy, cứ cách 2 số Fibonacci lẻ sẽ có 1 số Fibonacci chẵn và vì chuỗi Fibonacci là chuỗi truy hồi, nên chuỗi các số Fibonacci chẵn nằm ở những vị trí cách đều nhau như vậy cũng sẽ là chuỗi truy hồi.

Gọi `Fn` là số Fibonnaci thứ n

Gọi `Cn` là số Fibonacci chẵn thứ n

Chúng ta có: `Cn = 4*C(n-1) + C(n-2)` với `C1 = 2`, `C2 = 8`

Dễ dàng chứng minh được điều trên, ta thấy `Cn = F(3n - 1)`.

Khi đó, biểu thức cần chứng minh sẽ là: 
```
F(3n - 1) = 4*F(3n - 4) + F(3n - 7)
```
Đến đây khá đơn giản và mọi người có thể chứng minh tiếp thông qua tính chất `Fn = F(n - 1) + F(n - 2)`

Dựa trên ý tưởng trên, chúng ta có thể cải tiến hàm ```SumEvenFibonnaci```  như sau

Code C++

```c++
long long SumEvenFibonnaci(long long limit)
{
    long long result = 2;
    long long c1 = 2;
    long long c2 = 8;
    while (c2 <= limit)
    {
        result += c2;
        long long temp = c2;
        c2 = 4 * c2 + c1;
        c1 = temp;
    }
    return result;
}
```

Và kết quả dĩ nhiên cũng vẫn là pass **5/5**
![Hackerrank project euler bài 2 tổng fibonacci chẵn sum of ficonacci lập trình c++](https://lh3.googleusercontent.com/hsqmnTja4Ymo83PZlWyZzWzg4SNT9i3auwIrK5ag58CMk8DhisJzQM5N0vn0UKreQXg3-RuXilsL0yAh0tcVxZRBhSYEB08fvixzC1wX4i7swc4OxxGQrTNYBW3PmHXiNp4gEhczNg=w2400)

### Cách giải O(1)???
Thực ra trước khi bắt tay vào code bài này mình đã cầm giấy bút và nghĩ về một công thức tổng quát cho tổng này rồi. Tuy nhiên vì quá trình chứng minh phức tạp nên không thể trình bày trong bài viết, và khi code thử thì chạy trong lần đầu tiên nên mình đã bỏ dở hướng đi này (thật sự là mình cũng rất bất ngờ). 

Mình sẽ để lại công thức mình tìm được cho các bạn nào muốn phát triển thêm hướng đi này
![Công thức Fibonacci chẵn lập trình C++ project euler hacker rank](https://lh3.googleusercontent.com/XcngY8aAtaqqNO3Xqf-yLQSGxrC-SAEARDer0UoeUKh-nl65nWQOzuw2_GoMQYECCpNxBMVgZDlMfq2vbFS66W9jqZd4efTp4CFgPmd9L-nY6Z-LXWiGIqGxTVlrrJURyo1cbZVQAw=w2400)

Và `Sn` là tổng n phần tử của dãy Fibonacci chẵn (kết quả cần tìm)
![Công thức Fibonacci chẵn lập trình C++ project euler hacker rank](https://lh3.googleusercontent.com/XcMXO3JmjEDFBIOb59xX5fQGabxo_l81LLJd1EvIq_liggw1dum_3kNiomC-1inRAS-sMfxmADUlS6KedVzHsIyjZG5vlh68QnyTKe0snw_vNb-0TyrlfHdi6lUJ4KpGsb-tbL0BoA=w2400)

## Kết
Vì bài này cũng ở độ khó easy nên cũng không có gì để bàn luận gì thêm, rất bất ngờ là chỉ cần lần thử đầu tiên với thuật toán vét cạn đơn thuần là có thể chạy được. Nếu có rút ra bài học gì ở đây thì có lẽ là

> Code trước tiên phải chạy được rồi mới cần chạy đúng và cuối cùng là chạy nhanh

Hi vọng không có bạn nào cố gắng tìm cách giải O(1) trước khi chạy thử cách O(n) như mình.
